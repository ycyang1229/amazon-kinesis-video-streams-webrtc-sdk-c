From 37e89b8bdede4e5b622547d0469b6a323f844c01 Mon Sep 17 00:00:00 2001
From: ycyang <yc.yang1229@gmail.com>
Date: Tue, 29 Jun 2021 23:33:46 +0800
Subject: [PATCH] ecs-support-patch

---
 .../amazonaws/kinesis/video/common/Include.h  |  53 +++-
 src/source/Common/EcsCredentialProvider.c     | 293 ++++++++++++++++++
 src/source/Common/EcsCredentialProvider.h     |  64 ++++
 src/source/Common/Include_i.h                 |   2 +
 src/source/Common/IotCredentialProvider.c     |   2 +-
 src/source/Common/Lws/LwsCall.c               |  86 ++++-
 src/source/Common/Lws/LwsCall.h               |   1 +
 .../Common/Lws/LwsEcsCredentialProvider.c     |  16 +
 .../Common/Lws/LwsEcsCredentialProvider.h     |  16 +
 src/source/Common/RequestInfo.c               |   3 +-
 10 files changed, 532 insertions(+), 4 deletions(-)
 create mode 100644 src/source/Common/EcsCredentialProvider.c
 create mode 100644 src/source/Common/EcsCredentialProvider.h
 create mode 100644 src/source/Common/Lws/LwsEcsCredentialProvider.c
 create mode 100644 src/source/Common/Lws/LwsEcsCredentialProvider.h

diff --git a/src/include/com/amazonaws/kinesis/video/common/Include.h b/src/include/com/amazonaws/kinesis/video/common/Include.h
index 17080ca..2bde023 100644
--- a/src/include/com/amazonaws/kinesis/video/common/Include.h
+++ b/src/include/com/amazonaws/kinesis/video/common/Include.h
@@ -50,6 +50,10 @@ extern "C" {
 #define STATUS_FILE_CREDENTIAL_PROVIDER_OPEN_FILE_FAILED    STATUS_COMMON_PRODUCER_BASE + 0x00000022
 #define STATUS_FILE_CREDENTIAL_PROVIDER_INVALID_FILE_LENGTH STATUS_COMMON_PRODUCER_BASE + 0x00000023
 #define STATUS_FILE_CREDENTIAL_PROVIDER_INVALID_FILE_FORMAT STATUS_COMMON_PRODUCER_BASE + 0x00000024
+#define STATUS_ECS_AUTH_URI_FAILED                          STATUS_COMMON_PRODUCER_BASE + 0x00000025
+#define STATUS_ECS_AUTH_FAILED                              STATUS_COMMON_PRODUCER_BASE + 0x00000026
+#define STATUS_ECS_AUTH_RSP_FAILED                          STATUS_COMMON_PRODUCER_BASE + 0x00000027
+#define STATUS_MAX_ECS_TOKEN_LENGTH                         STATUS_COMMON_PRODUCER_BASE + 0x00000028
 /*!@} */
 
 /**
@@ -137,6 +141,11 @@ extern "C" {
  */
 #define MAX_IOT_THING_NAME_LEN MAX_STREAM_NAME_LEN
 
+/**
+ * Maximum allowed string length for ECS authorization token
+ */
+#define MAX_ECS_TOKEN_LEN 2048
+
 /**
  * Maximum allowed request header length
  */
@@ -259,6 +268,7 @@ extern "C" {
  * HTTPS Protocol scheme name
  */
 #define HTTPS_SCHEME_NAME "https"
+#define HTTP_SCHEME_NAME  "http"
 
 /**
  * WSS Protocol scheme name
@@ -283,6 +293,11 @@ extern "C" {
  */
 #define SCHEMA_DELIMITER_STRING (PCHAR) "://"
 
+/**
+ *  Port delimiter string
+ */
+#define PORT_DELIMITER_STRING ":"
+
 /**
  * Default canonical URI if we fail to get anything from the parsing
  */
@@ -471,6 +486,7 @@ struct __RequestInfo {
                                               //!< NOTE: In streaming mode the body will be NULL
                                               //!< NOTE: The body will follow the main struct
     UINT32 bodySize;                          //!< Size of the body in bytes
+    UINT32 port;                              //!< Port number of the request.
     CHAR url[MAX_URI_CHAR_LEN + 1];           //!< The URL for the request
     CHAR certPath[MAX_PATH_LEN + 1];          //!< CA Certificate path to use - optional
     CHAR sslCertPath[MAX_PATH_LEN + 1];       //!< SSL Certificate file path to use - optional
@@ -669,6 +685,41 @@ PUBLIC_API STATUS createLwsIotCredentialProviderWithTime(PCHAR, PCHAR, PCHAR, PC
  */
 PUBLIC_API STATUS freeIotCredentialProvider(PAwsCredentialProvider*);
 
+/**
+ * @brief Creates an ECS based AWS credential provider object using libWebSockets
+ *        https://docs.aws.amazon.com/greengrass/v2/developerguide/token-exchange-service-component.html
+ *        https://docs.aws.amazon.com/greengrass/v2/developerguide/component-environment-variables.html
+ *
+ * @param[in] PCHAR Full uri of ECS credentials which is retrieved from the environment variable(AWS_CONTAINER_CREDENTIALS_FULL_URI)
+ * @param[in] PCHAR Authorization token of ECS credentials which is retrieved from the environment variable(AWS_CONTAINER_AUTHORIZATION_TOKEN)
+ * @param[out] PAwsCredentialProvider* Constructed AWS credentials provider object
+ *
+ * @return STATUS code of the execution. STATUS_SUCCESS on success
+ */
+PUBLIC_API STATUS createLwsEcsCredentialProvider(PCHAR, PCHAR, PAwsCredentialProvider*);
+
+/**
+ * @brief Creates an ECS based AWS credential provider object with time function which is based on libCurl
+ *
+ * @param[in] PCHAR Full uri of ECS credentials which is retrieved from the environment variable(AWS_CONTAINER_CREDENTIALS_FULL_URI)
+ * @param[in] PCHAR Authorization token of ECS credentials which is retrieved from the environment variable(AWS_CONTAINER_AUTHORIZATION_TOKEN)
+ * @param[in] GetCurrentTimeFunc Custom current time function
+ * @param[in] UINT64 Time function custom data
+ * @param[out] PAwsCredentialProvider* Constructed AWS credentials provider object
+ *
+ * @return STATUS code of the execution. STATUS_SUCCESS on success
+ */
+PUBLIC_API STATUS createLwsEcsCredentialProviderWithTime(PCHAR, PCHAR, GetCurrentTimeFunc, UINT64, PAwsCredentialProvider*);
+
+/**
+ * @brief Frees an ECS based Aws credential provider object
+ *
+ * @param[in,out] PAwsCredentialProvider* Object to be destroyed.
+ *
+ * @return STATUS code of the execution. STATUS_SUCCESS on success
+ */
+PUBLIC_API STATUS freeEcsCredentialProvider(PAwsCredentialProvider*);
+
 /**
  * @brief Creates a File based AWS credential provider object
  *
@@ -720,7 +771,7 @@ PUBLIC_API STATUS freeFileCredentialProvider(PAwsCredentialProvider*);
  *
  * @return STATUS code of the execution. STATUS_SUCCESS on success
  */
-PUBLIC_API STATUS createRequestInfo(PCHAR, PCHAR, PCHAR, PCHAR, PCHAR, PCHAR, SSL_CERTIFICATE_TYPE, PCHAR, UINT64, UINT64, UINT64, UINT64,
+PUBLIC_API STATUS createRequestInfo(PCHAR, PCHAR, UINT32, PCHAR, PCHAR, PCHAR, PCHAR, SSL_CERTIFICATE_TYPE, PCHAR, UINT64, UINT64, UINT64, UINT64,
                                     PAwsCredentials, PRequestInfo*);
 
 /**
diff --git a/src/source/Common/EcsCredentialProvider.c b/src/source/Common/EcsCredentialProvider.c
new file mode 100644
index 0000000..48018c9
--- /dev/null
+++ b/src/source/Common/EcsCredentialProvider.c
@@ -0,0 +1,293 @@
+/**
+ * Kinesis Video Producer ECS based Credential Provider
+ */
+#define LOG_CLASS "EcsCredentialProvider"
+#include "Include_i.h"
+
+STATUS createEcsCredentialProviderWithTime(PCHAR ecsCredentialFullUri, PCHAR token, GetCurrentTimeFunc getCurrentTimeFn, UINT64 customData,
+                                           BlockingServiceCallFunc serviceCallFn, PAwsCredentialProvider* ppCredentialProvider)
+{
+    ENTERS();
+    STATUS retStatus = STATUS_SUCCESS;
+    PEcsCredentialProvider pEcsCredentialProvider = NULL;
+    PCHAR pStart, pEnd;
+    UINT32 len;
+    UINT32 port = 0;
+    UINT32 fullUriLen = 0;
+
+    CHK(ppCredentialProvider != NULL && ecsCredentialFullUri != NULL && token != NULL && serviceCallFn != NULL, STATUS_NULL_ARG);
+
+    pEcsCredentialProvider = (PEcsCredentialProvider) MEMCALLOC(1, SIZEOF(EcsCredentialProvider));
+    CHK(pEcsCredentialProvider != NULL, STATUS_NOT_ENOUGH_MEMORY);
+
+    pEcsCredentialProvider->credentialProvider.getCredentialsFn = getEcsCredentials;
+
+    // Store the time functionality and specify default if NULL
+    pEcsCredentialProvider->getCurrentTimeFn = (getCurrentTimeFn == NULL) ? commonDefaultGetCurrentTimeFunc : getCurrentTimeFn;
+    pEcsCredentialProvider->customData = customData;
+
+    fullUriLen = STRNLEN(ecsCredentialFullUri, MAX_URI_CHAR_LEN + 1);
+
+    CHK(fullUriLen <= MAX_URI_CHAR_LEN, MAX_URI_CHAR_LEN);
+    CHK_STATUS(getRequestHost(ecsCredentialFullUri, &pStart, &pEnd));
+    len = (UINT32)(pEnd - ecsCredentialFullUri);
+    STRNCPY(pEcsCredentialProvider->ecsGetCredentialEndpoint, ecsCredentialFullUri, len);
+    pEcsCredentialProvider->ecsGetCredentialEndpoint[len] = '\0';
+
+    CHK_STATUS(getHostPort(ecsCredentialFullUri + len, &pStart, &pEnd));
+    CHK_STATUS(STRTOUI32(pStart, pEnd, 10, &port));
+    pEcsCredentialProvider->port = port;
+    len = (ecsCredentialFullUri + fullUriLen) - pEnd;
+    STRNCPY(pEcsCredentialProvider->ecsGetCredentialResource, pEnd + 1, len);
+
+    CHK(STRNLEN(token, MAX_ECS_TOKEN_LEN + 1) <= MAX_ECS_TOKEN_LEN, STATUS_MAX_ECS_TOKEN_LENGTH);
+    STRNCPY(pEcsCredentialProvider->token, token, MAX_ECS_TOKEN_LEN);
+
+    pEcsCredentialProvider->serviceCallFn = serviceCallFn;
+
+    CHK_STATUS(ecsCurlHandler(pEcsCredentialProvider));
+
+CleanUp:
+
+    if (STATUS_FAILED(retStatus)) {
+        freeEcsCredentialProvider((PAwsCredentialProvider*) &pEcsCredentialProvider);
+        pEcsCredentialProvider = NULL;
+    }
+
+    // Set the return value if it's not NULL
+    if (ppCredentialProvider != NULL) {
+        *ppCredentialProvider = (PAwsCredentialProvider) pEcsCredentialProvider;
+    }
+
+    LEAVES();
+    return retStatus;
+}
+
+STATUS freeEcsCredentialProvider(PAwsCredentialProvider* ppCredentialProvider)
+{
+    ENTERS();
+    STATUS retStatus = STATUS_SUCCESS;
+    PEcsCredentialProvider pEcsCredentialProvider = NULL;
+
+    CHK(ppCredentialProvider != NULL, STATUS_NULL_ARG);
+
+    pEcsCredentialProvider = (PEcsCredentialProvider) *ppCredentialProvider;
+
+    // Call is idempotent
+    CHK(pEcsCredentialProvider != NULL, retStatus);
+
+    // Release the underlying AWS credentials object
+    freeAwsCredentials(&pEcsCredentialProvider->pAwsCredentials);
+
+    // Release the object
+    MEMFREE(pEcsCredentialProvider);
+
+    // Set the pointer to NULL
+    *ppCredentialProvider = NULL;
+
+CleanUp:
+
+    LEAVES();
+    return retStatus;
+}
+
+STATUS getEcsCredentials(PAwsCredentialProvider pCredentialProvider, PAwsCredentials* ppAwsCredentials)
+{
+    ENTERS();
+
+    STATUS retStatus = STATUS_SUCCESS;
+
+    PEcsCredentialProvider pEcsCredentialProvider = (PEcsCredentialProvider) pCredentialProvider;
+
+    CHK(pEcsCredentialProvider != NULL && ppAwsCredentials != NULL, STATUS_NULL_ARG);
+
+    // Fill the credentials
+    CHK_STATUS(ecsCurlHandler(pEcsCredentialProvider));
+
+    *ppAwsCredentials = pEcsCredentialProvider->pAwsCredentials;
+
+CleanUp:
+
+    LEAVES();
+    return retStatus;
+}
+
+STATUS parseEcsResponse(PEcsCredentialProvider pEcsCredentialProvider, PCallInfo pCallInfo)
+{
+    ENTERS();
+    STATUS retStatus = STATUS_SUCCESS;
+
+    UINT32 i, resultLen, accessKeyIdLen = 0, secretKeyLen = 0, sessionTokenLen = 0, expirationTimestampLen = 0;
+    INT32 tokenCount;
+    jsmn_parser parser;
+    jsmntok_t tokens[MAX_JSON_TOKEN_COUNT];
+    PCHAR accessKeyId = NULL, secretKey = NULL, sessionToken = NULL, expirationTimestamp = NULL, pResponseStr = NULL;
+    UINT64 expiration, currentTime;
+    CHAR expirationTimestampStr[MAX_EXPIRATION_LEN + 1];
+
+    CHK(pEcsCredentialProvider != NULL && pCallInfo != NULL, STATUS_NULL_ARG);
+
+    resultLen = pCallInfo->responseDataLen;
+    pResponseStr = pCallInfo->responseData;
+    CHK(resultLen > 0, STATUS_ECS_AUTH_FAILED);
+
+    jsmn_init(&parser);
+    tokenCount = jsmn_parse(&parser, pResponseStr, resultLen, tokens, SIZEOF(tokens) / SIZEOF(jsmntok_t));
+
+    CHK(tokenCount > 1, STATUS_INVALID_API_CALL_RETURN_JSON);
+    CHK(tokens[0].type == JSMN_OBJECT, STATUS_INVALID_API_CALL_RETURN_JSON);
+
+    for (i = 1; i < (UINT32) tokenCount; i++) {
+        if (compareJsonString(pResponseStr, &tokens[i], JSMN_STRING, (PCHAR) "AccessKeyId")) {
+            accessKeyIdLen = (UINT32)(tokens[i + 1].end - tokens[i + 1].start);
+            CHK(accessKeyIdLen <= MAX_ACCESS_KEY_LEN, STATUS_INVALID_API_CALL_RETURN_JSON);
+            accessKeyId = pResponseStr + tokens[i + 1].start;
+            i++;
+        } else if (compareJsonString(pResponseStr, &tokens[i], JSMN_STRING, (PCHAR) "SecretAccessKey")) {
+            secretKeyLen = (UINT32)(tokens[i + 1].end - tokens[i + 1].start);
+            CHK(secretKeyLen <= MAX_SECRET_KEY_LEN, STATUS_INVALID_API_CALL_RETURN_JSON);
+            secretKey = pResponseStr + tokens[i + 1].start;
+            i++;
+        } else if (compareJsonString(pResponseStr, &tokens[i], JSMN_STRING, (PCHAR) "Token")) {
+            sessionTokenLen = (UINT32)(tokens[i + 1].end - tokens[i + 1].start);
+            CHK(sessionTokenLen <= MAX_SESSION_TOKEN_LEN, STATUS_INVALID_API_CALL_RETURN_JSON);
+            sessionToken = pResponseStr + tokens[i + 1].start;
+            i++;
+        } else if (compareJsonString(pResponseStr, &tokens[i], JSMN_STRING, "Expiration")) {
+            expirationTimestampLen = (UINT32)(tokens[i + 1].end - tokens[i + 1].start);
+            CHK(expirationTimestampLen <= MAX_EXPIRATION_LEN, STATUS_INVALID_API_CALL_RETURN_JSON);
+            expirationTimestamp = pResponseStr + tokens[i + 1].start;
+            MEMCPY(expirationTimestampStr, expirationTimestamp, expirationTimestampLen);
+            expirationTimestampStr[expirationTimestampLen] = '\0';
+            i++;
+        }
+    }
+
+    CHK(accessKeyId != NULL && secretKey != NULL && sessionToken != NULL, STATUS_ECS_AUTH_RSP_FAILED);
+
+    currentTime = pEcsCredentialProvider->getCurrentTimeFn(pEcsCredentialProvider->customData);
+    CHK_STATUS(convertTimestampToEpoch(expirationTimestampStr, currentTime / HUNDREDS_OF_NANOS_IN_A_SECOND, &expiration));
+    DLOGD("Ecs credential expiration time %" PRIu64, expiration / HUNDREDS_OF_NANOS_IN_A_SECOND);
+
+    if (pEcsCredentialProvider->pAwsCredentials != NULL) {
+        freeAwsCredentials(&pEcsCredentialProvider->pAwsCredentials);
+        pEcsCredentialProvider->pAwsCredentials = NULL;
+    }
+
+    // Fix-up the expiration to be no more than max enforced token rotation to avoid extra token rotations
+    // as we are caching the returned value which is likely to be an hour but we are enforcing max
+    // rotation to be more frequent.
+    expiration = MIN(expiration, currentTime + MAX_ENFORCED_TOKEN_EXPIRATION_DURATION);
+
+    CHK_STATUS(createAwsCredentials(accessKeyId, accessKeyIdLen, secretKey, secretKeyLen, sessionToken, sessionTokenLen, expiration,
+                                    &pEcsCredentialProvider->pAwsCredentials));
+
+CleanUp:
+
+    LEAVES();
+    return retStatus;
+}
+
+STATUS ecsCurlHandler(PEcsCredentialProvider pEcsCredentialProvider)
+{
+    ENTERS();
+    STATUS retStatus = STATUS_SUCCESS;
+    UINT64 currentTime;
+    UINT32 formatLen = 0;
+    CHAR serviceUrl[MAX_URI_CHAR_LEN + 1];
+    PRequestInfo pRequestInfo = NULL;
+    CallInfo callInfo;
+
+    MEMSET(&callInfo, 0x00, SIZEOF(CallInfo));
+
+    // Refresh the credentials
+    currentTime = pEcsCredentialProvider->getCurrentTimeFn(pEcsCredentialProvider->customData);
+
+    CHK(pEcsCredentialProvider->pAwsCredentials == NULL ||
+            currentTime + ECS_CREDENTIAL_FETCH_GRACE_PERIOD > pEcsCredentialProvider->pAwsCredentials->expiration,
+        retStatus);
+
+    formatLen = SNPRINTF(serviceUrl, MAX_URI_CHAR_LEN, "%s/%s", pEcsCredentialProvider->ecsGetCredentialEndpoint,
+                         pEcsCredentialProvider->ecsGetCredentialResource);
+    CHK(formatLen > 0 && formatLen < MAX_URI_CHAR_LEN, STATUS_ECS_AUTH_URI_FAILED);
+
+    // Form a new request info based on the params
+    CHK_STATUS(createRequestInfo(serviceUrl, NULL, pEcsCredentialProvider->port, DEFAULT_AWS_REGION, NULL, NULL, NULL, SSL_CERTIFICATE_TYPE_PEM,
+                                 DEFAULT_USER_AGENT_NAME, ECS_REQUEST_CONNECTION_TIMEOUT, ECS_REQUEST_COMPLETION_TIMEOUT, DEFAULT_LOW_SPEED_LIMIT,
+                                 DEFAULT_LOW_SPEED_TIME_LIMIT, pEcsCredentialProvider->pAwsCredentials, &pRequestInfo));
+
+    callInfo.pRequestInfo = pRequestInfo;
+
+    // Append the Ecs header
+    CHK_STATUS(setRequestHeader(pRequestInfo, ECS_AUTH_TOKEN_HEADER, 0, pEcsCredentialProvider->token, 0));
+
+    // Perform a blocking call
+    CHK_STATUS(pEcsCredentialProvider->serviceCallFn(pRequestInfo, &callInfo));
+
+    // Parse the response and get the credentials
+    CHK_STATUS(parseEcsResponse(pEcsCredentialProvider, &callInfo));
+
+CleanUp:
+
+    if (pRequestInfo != NULL) {
+        freeRequestInfo(&pRequestInfo);
+    }
+
+    releaseCallInfo(&callInfo);
+
+    return retStatus;
+}
+
+STATUS getHostPort(PCHAR pUrl, PCHAR* ppStart, PCHAR* ppEnd)
+{
+    STATUS retStatus = STATUS_SUCCESS;
+    PCHAR pStart = NULL, pEnd = NULL, pCurPtr;
+    UINT32 urlLen;
+    BOOL iterate = TRUE;
+
+    CHK(pUrl != NULL && ppStart != NULL && ppEnd != NULL, STATUS_NULL_ARG);
+
+    // We know for sure url is NULL terminated
+    urlLen = (UINT32) STRNLEN(pUrl, MAX_URI_CHAR_LEN + 1);
+
+    // Start from the schema delimiter
+    pStart = STRSTR(pUrl, PORT_DELIMITER_STRING);
+    CHK(pStart != NULL, STATUS_INVALID_ARG);
+
+    // Advance the pStart past the delimiter
+    pStart += (ARRAY_SIZE(PORT_DELIMITER_STRING) - 1);
+
+    // Ensure we are not past the string
+    CHK(pUrl + urlLen > pStart, STATUS_INVALID_ARG);
+
+    // Set the end first
+    pEnd = pUrl + urlLen;
+
+    // Find the delimiter which would indicate end of the host - either one of "/:?"
+    pCurPtr = pStart;
+    while (iterate && pCurPtr <= pEnd) {
+        switch (*pCurPtr) {
+            case '/':
+            case ':':
+            case '?':
+                iterate = FALSE;
+
+                // Set the new end value
+                pEnd = pCurPtr;
+            default:
+                pCurPtr++;
+        }
+    }
+
+CleanUp:
+
+    if (ppStart != NULL) {
+        *ppStart = pStart;
+    }
+
+    if (ppEnd != NULL) {
+        *ppEnd = pEnd;
+    }
+
+    return retStatus;
+}
diff --git a/src/source/Common/EcsCredentialProvider.h b/src/source/Common/EcsCredentialProvider.h
new file mode 100644
index 0000000..c113af2
--- /dev/null
+++ b/src/source/Common/EcsCredentialProvider.h
@@ -0,0 +1,64 @@
+
+#ifndef __KINESIS_VIDEO_ECS_CREDENTIAL_PROVIDER_INCLUDE_I__
+#define __KINESIS_VIDEO_ECS_CREDENTIAL_PROVIDER_INCLUDE_I__
+
+#pragma once
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define ECS_REQUEST_CONNECTION_TIMEOUT (3 * HUNDREDS_OF_NANOS_IN_A_SECOND)
+#define ECS_REQUEST_COMPLETION_TIMEOUT (5 * HUNDREDS_OF_NANOS_IN_A_SECOND)
+#define ECS_AUTH_TOKEN_HEADER          "authorization"
+
+/**
+ * Service call callback functionality
+ */
+typedef STATUS (*BlockingServiceCallFunc)(PRequestInfo, PCallInfo);
+
+/**
+ * Grace period which is added to the current time to determine whether the extracted credentials are still valid
+ */
+#define ECS_CREDENTIAL_FETCH_GRACE_PERIOD                                                                                                            \
+    (5 * HUNDREDS_OF_NANOS_IN_A_SECOND + MIN_STREAMING_TOKEN_EXPIRATION_DURATION + STREAMING_TOKEN_EXPIRATION_GRACE_PERIOD)
+
+typedef struct __EcsCredentialProvider EcsCredentialProvider;
+struct __EcsCredentialProvider {
+    // First member should be the abstract credential provider
+    AwsCredentialProvider credentialProvider;
+
+    // Current time functionality - optional
+    GetCurrentTimeFunc getCurrentTimeFn;
+
+    // Custom data supplied to time function
+    UINT64 customData;
+
+    // Ecs credential endpoint
+    CHAR ecsGetCredentialEndpoint[MAX_URI_CHAR_LEN + 1];
+    CHAR ecsGetCredentialResource[MAX_URI_CHAR_LEN + 1];
+    CHAR token[MAX_ECS_TOKEN_LEN + 1];
+    UINT32 port;
+
+    // Static Aws Credentials structure with the pointer following the main allocation
+    PAwsCredentials pAwsCredentials;
+
+    // Service call functionality
+    BlockingServiceCallFunc serviceCallFn;
+};
+typedef struct __EcsCredentialProvider* PEcsCredentialProvider;
+
+////////////////////////////////////////////////////////////////////////
+// Callback function implementations
+////////////////////////////////////////////////////////////////////////
+STATUS createEcsCredentialProviderWithTime(PCHAR, PCHAR, GetCurrentTimeFunc, UINT64, BlockingServiceCallFunc, PAwsCredentialProvider*);
+STATUS getEcsCredentials(PAwsCredentialProvider, PAwsCredentials*);
+
+// internal functions
+STATUS ecsCurlHandler(PEcsCredentialProvider);
+STATUS parseEcsResponse(PEcsCredentialProvider, PCallInfo);
+STATUS getHostPort(PCHAR, PCHAR*, PCHAR*);
+#ifdef __cplusplus
+}
+#endif
+#endif /* __KINESIS_VIDEO_ECS_CREDENTIAL_PROVIDER_INCLUDE_I__ */
diff --git a/src/source/Common/Include_i.h b/src/source/Common/Include_i.h
index 56ae2ae..f931b57 100644
--- a/src/source/Common/Include_i.h
+++ b/src/source/Common/Include_i.h
@@ -73,9 +73,11 @@ typedef struct __CRYPTO_dynlock_value* PCRYPTO_dynlock_value;
 #if defined(KVS_BUILD_WITH_LWS)
 #include "Lws/LwsCall.h"
 #include "Lws/LwsIotCredentialProvider.h"
+#include "Lws/LwsEcsCredentialProvider.h"
 #endif
 
 #include "IotCredentialProvider.h"
+#include "EcsCredentialProvider.h"
 #include "AwsV4Signer.h"
 #include "Util.h"
 #include "RequestInfo.h"
diff --git a/src/source/Common/IotCredentialProvider.c b/src/source/Common/IotCredentialProvider.c
index a61218c..c95af1d 100644
--- a/src/source/Common/IotCredentialProvider.c
+++ b/src/source/Common/IotCredentialProvider.c
@@ -214,7 +214,7 @@ STATUS iotCurlHandler(PIotCredentialProvider pIotCredentialProvider)
     CHK(formatLen > 0 && formatLen < MAX_URI_CHAR_LEN, STATUS_IOT_FAILED);
 
     // Form a new request info based on the params
-    CHK_STATUS(createRequestInfo(serviceUrl, NULL, DEFAULT_AWS_REGION, pIotCredentialProvider->caCertPath, pIotCredentialProvider->certPath,
+    CHK_STATUS(createRequestInfo(serviceUrl, NULL, DEFAULT_SSL_PORT_NUMBER, DEFAULT_AWS_REGION, pIotCredentialProvider->caCertPath, pIotCredentialProvider->certPath,
                                  pIotCredentialProvider->privateKeyPath, SSL_CERTIFICATE_TYPE_PEM, DEFAULT_USER_AGENT_NAME,
                                  IOT_REQUEST_CONNECTION_TIMEOUT, IOT_REQUEST_COMPLETION_TIMEOUT, DEFAULT_LOW_SPEED_LIMIT,
                                  DEFAULT_LOW_SPEED_TIME_LIMIT, pIotCredentialProvider->pAwsCredentials, &pRequestInfo));
diff --git a/src/source/Common/Lws/LwsCall.c b/src/source/Common/Lws/LwsCall.c
index f06b588..cc069dd 100644
--- a/src/source/Common/Lws/LwsCall.c
+++ b/src/source/Common/Lws/LwsCall.c
@@ -88,6 +88,90 @@ CleanUp:
     return retStatus;
 }
 
+STATUS blockingLwsHttpCall(PRequestInfo pRequestInfo, PCallInfo pCallInfo)
+{
+    ENTERS();
+    STATUS retStatus = STATUS_SUCCESS;
+    PCHAR pHostStart, pHostEnd;
+    CHAR path[MAX_URI_CHAR_LEN + 1];
+    struct lws_context* lwsContext = NULL;
+    struct lws_context_creation_info creationInfo;
+    struct lws_client_connect_info connectInfo;
+    struct lws* clientLws = NULL;
+    volatile INT32 retVal = 0;
+    struct lws_protocols lwsProtocols[2];
+
+    CHK(pRequestInfo != NULL && pCallInfo != NULL, STATUS_NULL_ARG);
+
+    // Prepare the signaling channel protocols array
+    MEMSET(lwsProtocols, 0x00, SIZEOF(lwsProtocols));
+    lwsProtocols[0].name = HTTP_SCHEME_NAME;
+    lwsProtocols[0].callback = lwsIotCallbackRoutine;
+    lwsProtocols[1].name = NULL;
+    lwsProtocols[1].callback = NULL;
+
+    // Prepare the LWS context
+    MEMSET(&creationInfo, 0x00, SIZEOF(struct lws_context_creation_info));
+    creationInfo.options = 0;
+    creationInfo.port = CONTEXT_PORT_NO_LISTEN;
+    creationInfo.protocols = lwsProtocols;
+    creationInfo.timeout_secs = pRequestInfo->completionTimeout / HUNDREDS_OF_NANOS_IN_A_SECOND;
+    creationInfo.gid = -1;
+    creationInfo.uid = -1;
+    creationInfo.fd_limit_per_thread = 1 + 1 + 1;
+    creationInfo.client_ssl_ca_filepath = pRequestInfo->certPath;
+    creationInfo.client_ssl_cert_filepath = pRequestInfo->sslCertPath;
+    creationInfo.client_ssl_private_key_filepath = pRequestInfo->sslPrivateKeyPath;
+
+    CHK(NULL != (lwsContext = lws_create_context(&creationInfo)), STATUS_IOT_CREATE_LWS_CONTEXT_FAILED);
+
+    // Execute the LWS REST call
+    MEMSET(&connectInfo, 0x00, SIZEOF(struct lws_client_connect_info));
+    connectInfo.context = lwsContext;
+    connectInfo.ssl_connection = LCCSCF_ALLOW_INSECURE;
+    connectInfo.port = pRequestInfo->port;
+
+    CHK_STATUS(getRequestHost(pRequestInfo->url, &pHostStart, &pHostEnd));
+
+    // Store the path
+    STRNCPY(path, pHostEnd, MAX_URI_CHAR_LEN);
+    path[MAX_URI_CHAR_LEN] = '\0';
+
+    // NULL terminate the host
+    *pHostEnd = '\0';
+
+    connectInfo.address = pHostStart;
+    connectInfo.path = path;
+    connectInfo.host = connectInfo.address;
+    connectInfo.method = HTTP_REQUEST_VERB_GET_STRING;
+    connectInfo.protocol = lwsProtocols[0].name;
+    connectInfo.pwsi = &clientLws;
+
+    connectInfo.opaque_user_data = (PVOID) pCallInfo;
+
+    CHK(NULL != lws_client_connect_via_info(&connectInfo), STATUS_IOT_CREATE_LWS_CONTEXT_FAILED);
+
+    while (retVal >= 0 && !ATOMIC_LOAD_BOOL(&pCallInfo->pRequestInfo->terminating)) {
+        retVal = lws_service(lwsContext, 0);
+    }
+
+CleanUp:
+
+    if (lwsContext != NULL) {
+        // Trigger termination
+        ATOMIC_STORE_BOOL(&pCallInfo->pRequestInfo->terminating, TRUE);
+
+        // Cancel the ongoing service if any
+        lws_cancel_service(lwsContext);
+
+        // Destroy the context
+        lws_context_destroy(lwsContext);
+    }
+
+    LEAVES();
+    return retStatus;
+}
+
 INT32 lwsIotCallbackRoutine(struct lws* wsi, enum lws_callback_reasons reason, PVOID user, PVOID pDataIn, size_t dataSize)
 {
     UNUSED_PARAM(user);
@@ -259,4 +343,4 @@ CleanUp:
     } else {
         return retValue;
     }
-}
\ No newline at end of file
+}
diff --git a/src/source/Common/Lws/LwsCall.h b/src/source/Common/Lws/LwsCall.h
index e334506..2601250 100644
--- a/src/source/Common/Lws/LwsCall.h
+++ b/src/source/Common/Lws/LwsCall.h
@@ -12,6 +12,7 @@ extern "C" {
 #define IOT_LWS_SEND_BUFFER_SIZE (LWS_PRE + MAX_URI_CHAR_LEN)
 
 STATUS blockingLwsCall(PRequestInfo, PCallInfo);
+STATUS blockingLwsHttpCall(PRequestInfo, PCallInfo);
 INT32 lwsIotCallbackRoutine(struct lws*, enum lws_callback_reasons, PVOID, PVOID, size_t);
 
 #ifdef __cplusplus
diff --git a/src/source/Common/Lws/LwsEcsCredentialProvider.c b/src/source/Common/Lws/LwsEcsCredentialProvider.c
new file mode 100644
index 0000000..94c26f5
--- /dev/null
+++ b/src/source/Common/Lws/LwsEcsCredentialProvider.c
@@ -0,0 +1,16 @@
+/**
+ * Kinesis Video Producer ECS based Credential Provider for libWebSockets
+ */
+#define LOG_CLASS "LwsEcsCredentialProvider"
+#include "../Include_i.h"
+
+STATUS createLwsEcsCredentialProvider(PCHAR ecsCredentialFullUri, PCHAR token, PAwsCredentialProvider* ppCredentialProvider)
+{
+    return createLwsEcsCredentialProviderWithTime(ecsCredentialFullUri, token, commonDefaultGetCurrentTimeFunc, 0, ppCredentialProvider);
+}
+
+STATUS createLwsEcsCredentialProviderWithTime(PCHAR ecsCredentialFullUri, PCHAR token, GetCurrentTimeFunc getCurrentTimeFn, UINT64 customData,
+                                              PAwsCredentialProvider* ppCredentialProvider)
+{
+    return createEcsCredentialProviderWithTime(ecsCredentialFullUri, token, getCurrentTimeFn, customData, blockingLwsHttpCall, ppCredentialProvider);
+}
diff --git a/src/source/Common/Lws/LwsEcsCredentialProvider.h b/src/source/Common/Lws/LwsEcsCredentialProvider.h
new file mode 100644
index 0000000..93caa4c
--- /dev/null
+++ b/src/source/Common/Lws/LwsEcsCredentialProvider.h
@@ -0,0 +1,16 @@
+
+#ifndef __KINESIS_VIDEO_LWS_ECS_CREDENTIAL_PROVIDER_INCLUDE_I__
+#define __KINESIS_VIDEO_LWS_ECS_CREDENTIAL_PROVIDER_INCLUDE_I__
+
+#pragma once
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+STATUS blockingLwsHttpCall(PRequestInfo, PCallInfo);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* __KINESIS_VIDEO_LWS_ECS_CREDENTIAL_PROVIDER_INCLUDE_I__ */
diff --git a/src/source/Common/RequestInfo.c b/src/source/Common/RequestInfo.c
index adda706..f38e280 100644
--- a/src/source/Common/RequestInfo.c
+++ b/src/source/Common/RequestInfo.c
@@ -1,7 +1,7 @@
 #define LOG_CLASS "RequestInfo"
 #include "Include_i.h"
 
-STATUS createRequestInfo(PCHAR url, PCHAR body, PCHAR region, PCHAR certPath, PCHAR sslCertPath, PCHAR sslPrivateKeyPath,
+STATUS createRequestInfo(PCHAR url, PCHAR body, UINT32 port, PCHAR region, PCHAR certPath, PCHAR sslCertPath, PCHAR sslPrivateKeyPath,
                          SSL_CERTIFICATE_TYPE certType, PCHAR userAgent, UINT64 connectionTimeout, UINT64 completionTimeout, UINT64 lowSpeedLimit,
                          UINT64 lowSpeedTimeLimit, PAwsCredentials pAwsCredentials, PRequestInfo* ppRequestInfo)
 {
@@ -28,6 +28,7 @@ STATUS createRequestInfo(PCHAR url, PCHAR body, PCHAR region, PCHAR certPath, PC
     pRequestInfo->connectionTimeout = connectionTimeout;
     ATOMIC_STORE_BOOL(&pRequestInfo->terminating, FALSE);
     pRequestInfo->bodySize = bodySize;
+    pRequestInfo->port = port;
     pRequestInfo->currentTime = GETTIME();
     pRequestInfo->callAfter = pRequestInfo->currentTime;
     STRNCPY(pRequestInfo->region, region, MAX_REGION_NAME_LEN);
-- 
2.17.1

